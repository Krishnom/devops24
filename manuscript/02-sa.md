# TODO

- [X] Code
- [X] Code review Docker for Mac/Windows
- [X] Code review minikube
- [X] Code review kops
- [X] Code review minishift
- [X] Code review GKE
- [ ] Write
- [ ] Text review
- [ ] Diagrams
- [ ] Gist
- [ ] Review the title
- [ ] Proofread
- [ ] Add to slides
- [ ] Publish on TechnologyConversations.com
- [ ] Add to Book.txt
- [ ] Publish on LeanPub.com

# Service Accounts

T> Humans are not the only ones who operate a Kubernetes cluster. Processes in containers often need to invoke Kube API as well. When using RBAC for authentication, we need to decide which users will have permissions to perform certain actions. The same holds true for the processes running in containers.

When we (humans) try to access a Kubernetes cluster with RBAC enabled, we are authenticated as users. Our username provides an identity API server uses to decide whether we are allowed to perform certain actions. Processes running inside containers might also need to access the API. In such cases, they are authenticated as a specific ServiceAccount.

ServiceAccounts are the mechanism that will allow us to grant permissions to processes running inside containers. In many ways, ServiceAccounts are very similar to RBAC users or groups. With humans we use RoleBindings and ClusterRoleBindings to connect users and groups to Roles and ClusterRoles. When working with processes, the main difference is in the name and the scope. Instead of users or groups, we'll create ServiceAccounts which we'll bind to roles. Unlike users that are global, our ServiceAccounts will be tied to specific Namespaces.

I> This chapter asssumes that you are already familiar with Namespaces, Ingress, Deployments, Roles, ClusterRoles, RoleBindings, ClusterRoleBindings, Users, and Groups. If you're not, please refer to [The DevOps 2.3 Toolkit: Kubernetes](https://amzn.to/2GvzDjy) for more info.

We won't go into more theory. Instead, we'll try to learn different aspects of ServiceAccounts through hands-on examples.

## Creating A Cluster

We'll start the hands-on walk-through by entering the directory where we cloned the `vfarcic/k8s-specs` repository.

W> ## A note to Windows users
W>
W> Please run all the examples from *GitBash* (installed through *Git*). That way the commands you'll see throughout the book will be same as those that should be executed on *MacOS* or any *Linux* distribution. If you're using Hyper-V instead of VirtualBox, you may need to run the *GitBash* window as an Administrator.

```bash
cd k8s-specs
```

Next, we'll have to have a cluster which we can use to experiment with ServiceAccounts. The requirements are the same as those we used in the previous chapter. We'll need **Kubernetes version 1.9** or higher as well as **nginx Ingress Controller**, **RBAC**, and a **default StorageClass**. Please continue using the cluster you created in the previous chapter, if you didn't destroy it. Otherwise, it should be fairly fast to create a new one. For your convenience, the Gists and the specs we used before is available here as well.

* [docker4mac.sh](https://gist.github.com/06e313db2957e92b1df09fe39c249a14): **Docker for Mac** with 2 CPUs, 2GB RAM, and with nginx Ingress.
* [minikube.sh](https://gist.github.com/536e6329e750b795a882900c09feb13b): **minikube** with 2 CPUs, 2GB RAM, and with `ingress`, `storage-provisioner`, and `default-storageclass` addons enabled.
* [kops.sh](https://gist.github.com/2a3e4ee9cb86d4a5a65cd3e4397f48fd): **kops in AWS** with 3 t2.small masters and 2 t2.medium nodes spread in three availability zones, and with nginx Ingress (assumes that the prerequisites are set through [Appendix B](#appendix-b)).
* [minishift.sh](https://gist.github.com/c9968f23ecb1f7b2ec40c6bcc0e03e4f): **minishift** with 2 CPUs, 2GB RAM, and version 1.16+.
* [gke.sh](https://gist.github.com/5c52c165bf9c5002fedb61f8a5d6a6d1): **Google Kubernetes Engine (GKE)** with 3 n1-standard-1 (1 CPU, 3.75GB RAM) nodes (one in each zone), and with nginx Ingress controller running on top of the "standard" one that comes with GKE. We'll use nginx Ingress for compatibility with other platforms. Feel free to modify the YAML files if you prefer NOT to install nginx Ingress.

## Jenkins With Kubernetes

We'll start by creating the same Jenkins StatefulSet we used in the previous chapter. Once it's up-and-running, we'll try to use the [Jenkins Kubernetes plugin](https://github.com/jenkinsci/kubernetes-plugin). If we're successful, we'll have a tool which could be used to execute continuous delivery or deployment tasks inside a Kubernetes cluster.

```bash
cat sa/jenkins-no-sa.yml
```

We won't go through the definition since it is (almost) the same as the one we used in the previous chapter. There's no mystery that has to be revealed so we'll move on and create the resources defined in that YAML.

W> ## A note to **minishift** users
W>
W> OpenShift does not allow setting `fsGroup` in the security context, it uses Routes instead of Ingress, and Services accessible through Routes need to be the `LoadBalancer` type. Due to those changes, I had to prepare a different YAML specification for minishift. Please execute `oc apply -f sa/jenkins-no-sa-oc.yml --record` instead of the command that follows.

```bash
kubectl apply \
    -f sa/jenkins-no-sa.yml \
    --record

kubectl -n jenkins \
    rollout status sts jenkins
```

The latter command should tell us when the rollout is complete and Jenkins is ready for us.

W> ## A note to GKE users
W>
W> GKE uses external load balancer as Ingress. To work properly, `type` of the service related to Ingress needs to be `NodePort`. We'll have to patch the service to change its type. Please execute the command that follows.
W> `kubectl -n jenkins patch svc jenkins -p '{"spec":{"type": "NodePort"}}'`

Next, we'll discover the DNS (or IP) of the load balancer.

W> ## A note to GKE users
W>
W> Please change `hostname` to `ip` in the command that follows. The `jsonpath` should be `{.status.loadBalancer.ingress[0].ip}`. Please note that GKE Ingress spins up an external load balancer and it might take a while until the IP is generated. You might need to repeat the command that follows until you get the IP. TODO: Add to 01-sts.md

W> ## A note to minikube users
W>
W> Please change the command that follows to `CLUSTER_DNS=$(minikube ip)`.

W> ## A note to minishift users
W>
W> Please change the command that follows to `CLUSTER_DNS=jenkins-jenkins.$(minishift ip).nip.io`.

```bash
CLUSTER_DNS=$(kubectl -n jenkins \
    get ing jenkins \
    -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")

echo $CLUSTER_DNS
```

Now that we know the address of the cluster, we can proceed and open Jenkins UI in a browser.

```bash
open "http://$CLUSTER_DNS/jenkins"
```

W> In some cases (e.g., GKE), it might take a few minutes until the external load balancer is created. If you see 40x or 50x error message, please wait for a while and try to open Jenkins in the browser again.

Now we need to go through the setup wizard. It's a boring process that we already did before and I'm sure you're not thrilled with the prospects of going through it again. However, we're still missing knowledge and tools that will allow us to automate the process so we'll have to go through it again.

The first step is to get the initial admin password.

```bash
kubectl -n jenkins \
    exec jenkins-0 -it -- \
    cat /var/jenkins_home/secrets/initialAdminPassword
```

Please copy the output and paste it into Jenkins UI *Administrator password* field. Click the *Continue* button, followed with a click to *Install suggested plugins* button. Fill in the *Create First Admin User* fields and press the *Save and Finish* button. Finally, Jenkins is ready and only a click away. Please press the *Start using Jenkins* button.

If we are to use the [Kubernetes plugin](https://github.com/jenkinsci/kubernetes-plugin), we need to install it first. We'll open the available plugins section of the plugin manager screen.

```bash
open "http://$CLUSTER_DNS/jenkins/pluginManager/available"
```

Type *Kubernetes* in the *Filter* field and select the checkbox next to it.

Since we are already in the plugin manager screen, we might just as well install BlueOcean as well and make Jenkins prettier.

Type *BlueOcean* in the *Filter* field and select the checkbox next to it.

Now that we selected the plugins we want, the next step is to install them. Please click the *Install without restart* button and wait until all the plugins (and their dependencies) are installed.

We are not yet finished. We still need to configure the newly installed Kubernetes plugin.

```bash
open "http://$CLUSTER_DNS/jenkins/configure"
```

The plugin adds Kubernetes as yet another *Cloud* provider. Please click the *Add a new cloud* drop-down list in the *Cloud* section, and select *Kubernetes*. The cloud section should be somewhere close to the bottom of the screen.

Now that we added Kubernetes as a Cloud provider, we should confirm that it actually works. Please click the *Test Connection* button.

Unless you forgot to unable RBAC in your cluster, the output should be similar to the one that follows.

```
Error testing connection : Failure executing: GET at: https://kubernetes.default.svc/api/v1/namespaces/jenkins/pods. Message: Forbidden!Configured service account doesn't have access. Service account may have been revoked. pods is forbidden: User "system:serviceaccount:jenkins:default" cannot list pods in the namespace "jenkins".
```

W> ## A note to **Docker For Mac/Windows** users
W>
W> Even though Docker for Mac/Windows supports RBAC, it allows any internal process inside containers to communicate with Kube API. That is quite the opposite from what you'll experience in other Kubernetes platforms. As a result, you'll see quite a few discrepancies between the outputs in this chapter and those you'll see in your cluster. You'll notice that you'll be able to perform actions that are forbidden in other Kubernetes platforms.

API server rejected our request to list the Pods in the `jenkins` Namespace. Such a reaction makes perfect sense. If any process in any container could do request anything from the API, our security efforts would be useless. What would be the point of trying to restrict users (humans) if all it takes is to create a single Pod that sends a request to the API server. It rightfully denied our request to list the Pods.

Just as a username provides a sort of identity to humans, a ServiceAccount is an identity for all the processes that run in containers. Since we did not specify any ServiceAccount for the Pod where Jenkins is running, Kubernetes assigned one for us. The Pod is authenticated as `default` account which happens to be bound to roles that give almost no permissions. In other words, if we do not define a ServiceAccount for a Pod, it'll be associated with the ServiceAccount `default`, and the processes inside that Pod will not be able to requests almost anything from the API server.

A `default` ServiceAccount is created for every Namespace in the cluster. It is, in a way, similar to the default StorageClass. If a Pod does not have a ServiceAccount, it'll get the `default`. The `default` ServiceAccount has very limited privileges and it cannot do almost anything. We can bind more permissive role to the `default` ServiceAccount but that would be a very uncommon solution to the problem.

We need to associate Jenkins process with an entity that has more permissions. As a minimum, we need to be able to list the Pod in the `jenkins` Namespace. To do that, we need to learn about ServiceAccounts first.

We'll delete `jenkins` Namespace and explore ServiceAccounts in our quest to enable and control the communication between API server and processes running in containers.

```bash
kubectl delete ns jenkins
```

## With The `default` ServiceAccount

Jenkins might not be the best starting point in our exploration of ServiceAccounts. Too many things are happening out of our control. There's too much "magic" hidden behind Jenkins code. Instead, we'll start with something simpler. We'll run `kubectl` as a Pod. If we manage to make that work, we should have no problem applying the knowledge to Jenkins and MongoDB side-car.

Unfortunately, there is no `kubectl` official image (at least not in Docker Hub), so I built one. The definition is in the [vfarcic/kubectl](https://github.com/vfarcic/kubectl) GitHub repository. Let's take a quick look.

```bash
curl https://raw.githubusercontent.com/vfarcic/kubectl/master/Dockerfile
```

The Dockerfile is so simple and uneventful that there's probably no need going through it. It's a `kubectl` binary in an `alpine` based image. Not more, not less.

Let's run it.

```bash
kubectl run kubectl \
    --image=vfarcic/kubectl \
    --restart=Never \
    sleep 10000
```

We should wait for a few moments until the image is pulled and the container that forms the Pod is running.

Let's start by checking out the `serviceAccount` entry in the specification.

```bash
kubectl get pod kubectl \
    -o jsonpath="{.spec.serviceAccount}"
```

The output is as follows.

```
default
```

Since we did not specify an ServiceAccount, the `default` one that was created with the Namaspace was assigned to the Pod automatically.

We might be able to dig a bit more infomation from within the `kubect` container.

```bash
kubectl exec -it kubectl -- sh
```

No matter which ServiceAccount is used, Kubernetes always mount a secret with the information about that account. The secret is mounted inside the `/var/run/secrets/kubernetes.io/serviceaccount` directory. 

```bash
cd /var/run/secrets/kubernetes.io/serviceaccount

ls -la
```

We entered into the secret's directory and list all the files. The output is as follows.

```
total 4
drwxrwxrwt 3 root root  140 May 7 00:35 .
drwxr-xr-x 3 root root 4096 May 7 00:35 ..
drwxr-xr-x 2 root root  100 May 7 00:35 ..2018_05_07_00_35_25.899750157
lrwxrwxrwx 1 root root   31 May 7 00:35 ..data -> ..2018_05_07_00_35_25.899750157
lrwxrwxrwx 1 root root   13 May 7 00:35 ca.crt -> ..data/ca.crt
lrwxrwxrwx 1 root root   16 May 7 00:35 namespace -> ..data/namespace
lrwxrwxrwx 1 root root   12 May 7 00:35 token -> ..data/token
```

We can see that it created three soft-links (`ca.crt`, `namespace`, and `token`) that point to a directory that contains the actual files. You should be able to guess what those files contain. The token and the certificate are used as authentication when communicating with the API server. The third file contains only the Namespace in which the Pod is running.

Let's try a very simple operation.

```bash
kubectl get pods
```

The output is as follows.

```
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:default:default" cannot list pods in the namespace "default"
```

We got a similar error message as when we tried to use Jenkins' Kubernetes plugin without any credentials. Once again we're faced with limited permissions bound to the `default` account. We'll change that soon. For now, we'll exit the container and remove the `kubectl` Pod.

```bash
exit

kubectl delete pod kubectl
```

We saw the limitations behind the `default` account. We'll try to overcome those limitations by creating our own ServiceAccounts.

## With ServiceAccount

Let's take a look at the service accounts currently available in the `default` Namespace.

```bash
kubectl get sa
```

The output is as follows.

```
NAME    SECRETS AGE
default 1       24m
```

At the moment, there is only one ServiceAccount called `default`. We already saw that account cannot do almost anything. It is stripped from (almost) all the privileges. If we check the other Namespaces, we'll notice that all of them have only the `default` ServiceAccount. Whenever we create a new Namespace, Kubernetes creates that account for us.

W> ## A note to **minishift** users
W>
W> OpenShift is an exception. Unlike most other Kubernetes flavors, it created a few ServiceAccounts in the `default` Namespace. Feel free to explore them later when you learn more about ServiceAccounts and their relations to Roles.

We already established that we'll need to create new ServiceAccounts if we are ever to allow processes in containers to communicate with Kube API. As the first exercise, we'll create an account that will allow us to view (almost) all the resources in the `default` Namespace. The definition is available in the `sa/view.yml` file.

```bash
cat sa/view.yml
```

The output is as follows.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: view

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: view
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: ServiceAccount
  name: view
```

The YAML defines two resources. The first one is the `ServiceAccount` named `view`. The ServiceAccount kind is on pair with Namespace in its simplicity. Excluding a few flags which we won't explore just yet, the only thing we can do with it is to declare its existence. The real magic is defined in the RoleBinding.

Just as with RBAC users and groups, RoleBinding are tying a Role or a ClusterRole with a ServiceAccount. Since our objective to provide view permissions can be fulfilled with the ClusterRole `view`, we did not need to create a role ourselves. Instead, we're binding the ClusterRole `view` with the ServiceAccount with the same name.

If you are already experienced with RBAC applied to users and groups, you probably noticed that ServiceAccounts follow the same rules. The only substantial difference, from YAML perspective, is that the `kind` of the subject is not `ServiceAccount` instead being `User` or `Group`.

Let's create the YAML and observe the results.

```bash
kubectl apply \
    -f sa/view.yml \
    --record
```

TODO: Continue writing

```
serviceaccount "view" created
rolebinding "view" created
```

```bash
kubectl get sa
```

```
NAME    SECRETS AGE
default 1       27m
view    1       6s
```

```bash
kubectl describe sa view
```

```
Name:         view
Namespace:    default
Labels:       <none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"ServiceAccount","metadata":{"annotations":{},"name":"view","namespace":"default"}}

                     kubernetes.io/change-cause=kubectl apply --filename=sa/view.yml --record=true
Image pull secrets:  <none>
Mountable secrets:   view-token-292vm
Tokens:              view-token-292vm
Events:              <none>
```

```bash
kubectl describe rolebinding view
```

```
Name:         view
Labels:       <none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"rbac.authorization.k8s.io/v1beta1","kind":"RoleBinding","metadata":{"annotations":{},"name":"view","namespace":"default"},"roleRef":{"ap...
              kubernetes.io/change-cause=kubectl apply --filename=sa/view.yml --record=true
Role:
  Kind:  ClusterRole
  Name:  view
Subjects:
  Kind            Name  Namespace
  ----            ----  ---------
  ServiceAccount  view
```

```bash
cat sa/kubectl-view.yml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test
spec:
  serviceAccountName: view
  containers:
  - name: test
    image: alpine:3.5
    command: ["sleep"]
    args: ["100000"]
```

```bash
kubectl apply \
    -f sa/kubectl-view.yml \
    --record

kubectl describe pod kubectl
```

```
Name:         kubectl
Namespace:    default
Node:         ip-172-20-103-156.us-east-2.compute.internal/172.20.103.156
Start Time:   Thu, 12 Apr 2018 16:50:51 +0200
Labels:       <none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{},"name":"kubectl","namespace":"default"},"spec":{"containers":[{"args":["100000"],"command"...
              kubernetes.io/change-cause=kubectl apply --filename=sa/kubectl-view.yml --record=true
              kubernetes.io/limit-ranger=LimitRanger plugin set: cpu request for container kubectl
Status:       Running
IP:           100.96.2.8
Containers:
  kubectl:
    Container ID:  docker://4e3b3dff00be4a77d9f45f5411677b4c3c0fa2d18f901d75d69d12d711fa5048
    Image:         vfarcic/kubectl
    Image ID:      docker-pullable://vfarcic/kubectl@sha256:023246835010501391e7851673eb9e08d068b29dd215abdb17df8ae9b7cddee0
    Port:          <none>
    Command:
      sleep
    Args:
      100000
    State:          Running
      Started:      Thu, 12 Apr 2018 16:50:56 +0200
    Ready:          True
    Restart Count:  0
    Requests:
      cpu:        100m
    Environment:  <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from view-token-292vm (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          True 
  PodScheduled   True 
Volumes:
  view-token-292vm:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  view-token-292vm
    Optional:    false
QoS Class:       Burstable
Node-Selectors:  <none>
Tolerations:     node.alpha.kubernetes.io/notReady:NoExecute for 300s
                 node.alpha.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason                 Age   From                                                   Message
  ----    ------                 ----  ----                                                   -------
  Normal  Scheduled              8s    default-scheduler                                      Successfully assigned kubectl to ip-172-20-103-156.us-east-2.compute.internal
  Normal  SuccessfulMountVolume  8s    kubelet, ip-172-20-103-156.us-east-2.compute.internal  MountVolume.SetUp succeeded for volume "view-token-292vm"
  Normal  Pulling                7s    kubelet, ip-172-20-103-156.us-east-2.compute.internal  pulling image "vfarcic/kubectl"
  Normal  Pulled                 3s    kubelet, ip-172-20-103-156.us-east-2.compute.internal  Successfully pulled image "vfarcic/kubectl"
  Normal  Created                3s    kubelet, ip-172-20-103-156.us-east-2.compute.internal  Created container
  Normal  Started                3s    kubelet, ip-172-20-103-156.us-east-2.compute.internal  Started container
```

```bash
kubectl exec -it kubectl -- sh

kubectl get pods
```

```
NAME READY STATUS  RESTARTS AGE
test 1/1   Running 0        55s
```

# TODO: minishift output

```
NAME                    READY STATUS  RESTARTS AGE
docker-registry-1-mx2fk 1/1   Running 0        24m
kubectl                 1/1   Running 0        22s
router-1-jgp54          1/1   Running 0        24m
```

```bash
kubectl run new-test \
    --image=alpine \
    --restart=Never \
    sleep 10000
```

```
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:default:view" cannot create pods in the namespace "default"
```

```bash
exit

kubectl delete -f sa/kubectl-view.yml
```

```
pod "kubectl" deleted
```

```bash
cat sa/pods.yml
```

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pods-all
  namespace: test1

---

kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: pods-all
  namespace: test1
rules:
- apiGroups: [""]
  resources: ["pods", "pods/exec", "pods/log"]
  verbs: ["*"]

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: pods-all
  namespace: test1
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pods-all
subjects:
- kind: ServiceAccount
  name: pods-all
```

```bash
kubectl apply -f sa/pods.yml \
    --record

kubectl create ns test2

cat sa/kubectl-test1.yml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubectl
  namespace: test1
spec:
  serviceAccountName: pods-all
  containers:
  - name: kubectl
    image: vfarcic/kubectl
    command: ["sleep"]
    args: ["100000"]
```

```bash
kubectl apply \
    -f sa/kubectl-test1.yml \
    --record

kubectl -n test1 exec -it kubectl -- sh

kubectl get pods
```

```
NAME    READY STATUS  RESTARTS AGE
kubectl 1/1   Running 0        5m
```

```bash
kubectl run new-test \
    --image=alpine \
    --restart=Never \
    sleep 10000
```

```
pod "new-test" created
```

```bash
kubectl get pods
```

```
NAME     READY STATUS  RESTARTS AGE
kubectl  1/1   Running 0        6m
new-test 1/1   Running 0        17s
```

```bash
kubectl run new-test \
    --image=alpine sleep 10000
```

```
Error from server (Forbidden): deployments.extensions is forbidden: User "system:serviceaccount:test1:pods-all" cannot create deployments.extensions in the namespace "test1"
```

```bash
kubectl -n test2 get pods
```

```
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:test1:pods-all" cannot list pods in the namespace "test2"
```

The ServiceAccount was created in the `test1` Namespace. Only the Pods created in the same Namespace can be attached to the `pods-all` ServiceAccount. However, in this case, the important thing to note is that the RoleBinding that gives us the permissions to, for example, retrieve the Pods, exists only the in `test1` Namespace. The moment we tried to retrieve the Pods from a different Namespace, the API server responded with an error notifying us that we do not have permissions to `list pods in the namespace "test2"`.

T> While user accounts are global, ServiceAccounts are namespaced. After all, a human user is almost always invoking the API from outside the cluster while the processes inside containers are always inside Pods which are inside Namespaces.

TODO: Continue writing

```bash
exit

kubectl delete -f sa/kubectl-test1.yml

cat sa/pods-all.yml
```

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pods-all
  namespace: test1

---

kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: pods-all
  namespace: test1
rules:
- apiGroups: [""]
  resources: ["pods", "pods/exec", "pods/log"]
  verbs: ["*"]

---

kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: pods-all
  namespace: test2
rules:
- apiGroups: [""]
  resources: ["pods", "pods/exec", "pods/log"]
  verbs: ["*"]

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: pods-all
  namespace: test1
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pods-all
subjects:
- kind: ServiceAccount
  name: pods-all

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: pods-all
  namespace: test2
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pods-all
subjects:
- kind: ServiceAccount
  name: pods-all
  namespace: test1
```

```bash
kubectl apply -f sa/pods-all.yml \
    --record

cat sa/kubectl-test2.yml
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubectl
  namespace: test1
spec:
  serviceAccountName: pods-all
  containers:
  - name: kubectl
    image: vfarcic/kubectl
    command: ["sleep"]
    args: ["100000"]
```

```bash
kubectl apply \
    -f sa/kubectl-test2.yml \
    --record

kubectl -n test1 exec -it kubectl -- sh

kubectl get pods
```

```
NAME     READY STATUS  RESTARTS AGE
kubectl  1/1   Running 0        22s
new-test 1/1   Running 0        2m
```

```bash
kubectl -n test2 get pods
```

```
No resources found.
```

```bash
kubectl -n test2 \
    run new-test \
    --image=alpine \
    --restart=Never \
    sleep 10000
```

```
pod "new-test" created
```

```bash
kubectl -n test2 get pods
```

```
NAME     READY STATUS  RESTARTS AGE
new-test 1/1   Running 0        18s
```

```bash
kubectl -n default get pods
```

```
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:test1:pods-all" cannot list pods in the namespace "default"
```

```bash
kubectl -n kube-system get pods
```

```
Error from server (Forbidden): pods is forbidden: User "system:serviceaccount:test1:pods-all" cannot list pods in the namespace "kube-system"
```

```bash
exit

kubectl delete ns test1 test2
```

```
namespace "test1" deleted
namespace "test2" deleted
```

## Jenkins w/Kubernetes (again)

```bash
cat sa/jenkins.yml
```

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: jenkins

---

apiVersion: v1
kind: Namespace
metadata:
  name: build

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: jenkins

---

kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: jenkins
  namespace: build
rules:
- apiGroups: [""]
  resources: ["pods", "pods/exec", "pods/log"]
  verbs: ["*"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: jenkins
  namespace: build
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: jenkins
subjects:
- kind: ServiceAccount
  name: jenkins
  namespace: jenkins

---

apiVersion: v1
kind: Service
metadata:
  name: jenkins
  namespace: jenkins
spec:
  selector:
    app: jenkins
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: agent
    port: 50000
    protocol: TCP

---

apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: jenkins
  namespace: jenkins
  annotations:
    ingress.kubernetes.io/ssl-redirect: "false"
    ingress.kubernetes.io/proxy-body-size: 50m
    ingress.kubernetes.io/proxy-request-buffering: "off"
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/proxy-body-size: 50m
    nginx.ingress.kubernetes.io/proxy-request-buffering: "off"
spec:
  rules:
  - http:
      paths:
      - path: /jenkins
        backend:
          serviceName: jenkins
          servicePort: 80

---

apiVersion: apps/v1beta2
kind: StatefulSet
metadata:
  name: jenkins
  namespace: jenkins
spec:
  selector:
    matchLabels:
      app: jenkins
  serviceName: jenkins
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      terminationGracePeriodSeconds: 10
      serviceAccountName: jenkins
      containers:
      - name: jenkins
        image: jenkins/jenkins:lts-alpine
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
        - containerPort: 50000
        resources:
          limits:
            cpu: 1
            memory: 1Gi
          requests:
            cpu: 0.5
            memory: 500Mi
        env:
        - name: JENKINS_OPTS
          value: --prefix=/jenkins
        - name: LIMITS_MEMORY
          valueFrom:
            resourceFieldRef:
              resource: limits.memory
              divisor: 1Mi
        - name: JAVA_OPTS
          value: -Xmx$(LIMITS_MEMORY)m -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85
        volumeMounts:
        - name: jenkins-home
          mountPath: /var/jenkins_home
        livenessProbe:
          httpGet:
            path: /jenkins/login
            port: 8080
          initialDelaySeconds: 60
          timeoutSeconds: 5
          failureThreshold: 12 # ~2 minutes
        readinessProbe:
          httpGet:
            path: /jenkins/login
            port: 8080
          initialDelaySeconds: 60
          timeoutSeconds: 5
          failureThreshold: 12 # ~2 minutes
      securityContext:
        fsGroup: 1000
  volumeClaimTemplates:
  - metadata:
      name: jenkins-home
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 2Gi
```

W> ## A note tominishift users
W>
W> Due to the changes required for OpenShift, we'll use a different YAML specification. Please execute `oc apply -f sa/jenkins-oc.yml --record` instead of the command that follows.

```bash
kubectl apply \
    -f sa/jenkins.yml \
    --record
```

```
namespace "jenkins" created
namespace "build" created
serviceaccount "jenkins" created
role "jenkins" created
rolebinding "jenkins" created
service "jenkins" created
ingress "jenkins" created
statefulset "jenkins" created
```

W> ## A note to GKE users
W>
W> GKE uses external load balancer as Ingress. To work properly, `type` of the service related to Ingress needs to be `NodePort`. We'll have to patch the service to change its type. Please execute the command that follows.
W> `kubectl -n jenkins patch svc jenkins -p '{"spec":{"type": "NodePort"}}'`

```bash
kubectl -n jenkins \
    rollout status sts jenkins
```

```
    rollout status sts jenkins
Waiting for 1 pods to be ready...
statefulset rolling update complete 1 pods at revision jenkins-55b49b8867...
```

```bash
open "http://$CLUSTER_DNS/jenkins"

kubectl -n jenkins \
    exec jenkins-0 -it -- \
    cat /var/jenkins_home/secrets/initialAdminPassword

# Copy the output and paste it into Jenkins UI *Administrator password* field

# Click the *Continue* button

# Click the *Install suggested plugins* button

# Fill in the *Create First Admin User* fields

# Click the *Save and Finish* button

# Click the *Start using Jenkins* button

open "http://$CLUSTER_DNS/jenkins/pluginManager/available"

# Type *Kubernetes* in the *Filter* field

# Select *Kubernetes* checkbox

# Type *BlueOcean* in the *Filter* field

# Select *BlueOcean* checkbox

# Click the *Install without restart* button

open "http://$CLUSTER_DNS/jenkins/configure"

# Click the *Add a new cloud* drop-down list in the *Cloud* section

# Select *Kubernetes*

# Click the *Test Connection* button
```

```
Error testing connection : Failure executing: GET at: https://kubernetes.default.svc/api/v1/namespaces/jenkins/pods. Message: Forbidden!Configured service account doesn't have access. Service account may have been revoked. pods is forbidden: User "system:serviceaccount:jenkins:jenkins" cannot list pods in the namespace "jenkins".
```


```bash
# Type *build* in the *Kubernetes Namespace* field

# Click the *Test Connection* button
```

```
Connection test successful
```

```bash
# Type *http://jenkins.jenkins/jenkins* in the *Jenkins URL* field

# Click the *Save* button

# Click the *New Item* link in the left-hand menu

# Type *my-k8s-job* in the *item name* field

# Select *Pipeline* as the type

# Click the *OK* button

# Click the *Pipeline* tab

# Write the script that follows in the *Pipeline Script* field
```

```groovy
podTemplate(
    label: 'kubernetes',
    containers: [
        containerTemplate(name: 'maven', image: 'maven:alpine', ttyEnabled: true, command: 'cat'),
        containerTemplate(name: 'golang', image: 'golang:alpine', ttyEnabled: true, command: 'cat')
    ]
) {
    node('kubernetes') {
        container('maven') {
            stage('build') {
                sh 'mvn --version'
            }
            stage('unit-test') {
                sh 'java -version'
            }
        }
        container('golang') {
            stage('deploy') {
                sh 'go version'
            }
        }
    }
}
```

```bash
# Click the *Save* button

# Click the *Open Blue Ocean* link from the left-hand menu

# Click the *Run* button

# TODO: It might take a while until all the images are pulled

kubectl -n build get pods
```

```
NAME              READY STATUS            RESTARTS AGE
jenkins-slave-... 0/3   ContainerCreating 0        11s
```

```bash
kubectl -n build get pods
```

```
NAME              READY STATUS  RESTARTS AGE
jenkins-slave-... 3/3   Running 0        5s
```

```bash
kubectl -n build get pods
```

```
NAME              READY STATUS      RESTARTS AGE
jenkins-slave-... 3/3   Terminating 0        32s
```

```bash
kubectl delete ns jenkins build
```

## Mongo

```bash
cat sa/go-demo-3.yml
```

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: go-demo-3

---

apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: api
  namespace: go-demo-3
  annotations:
    ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  rules:
  - http:
      paths:
      - path: /demo
        backend:
          serviceName: api
          servicePort: 8080

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: db
  namespace: go-demo-3

---

kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: db
  namespace: go-demo-3
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["list"]

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: db
  namespace: go-demo-3
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: db
subjects:
- kind: ServiceAccount
  name: db

---

apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: db
  namespace: go-demo-3
spec:
  serviceName: db
  replicas: 3
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      serviceAccountName: db
      terminationGracePeriodSeconds: 10
      containers:
      - name: db
        image: mongo:3.3
        command:
          - mongod
          - "--replSet"
          - rs0
          - "--smallfiles"
          - "--noprealloc"
        ports:
          - containerPort: 27017
        resources:
          limits:
            memory: "100Mi"
            cpu: 0.1
          requests:
            memory: "50Mi"
            cpu: 0.01
        volumeMounts:
        - name: mongo-data
          mountPath: /data/db
      - name: db-sidecar
        image: cvallance/mongo-k8s-sidecar
        env:
        - name: MONGO_SIDECAR_POD_LABELS
          value: "app=db"
        - name: KUBE_NAMESPACE
          value: go-demo-3
        - name: KUBERNETES_MONGO_SERVICE_NAME
          value: db
  volumeClaimTemplates:
  - metadata:
      name: mongo-data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 2Gi

---

apiVersion: v1
kind: Service
metadata:
  name: db
  namespace: go-demo-3
spec:
  ports:
  - port: 27017
  clusterIP: None
  selector:
    app: db

---

apiVersion: apps/v1beta2
kind: Deployment
metadata:
  name: api
  namespace: go-demo-3
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: vfarcic/go-demo-3
        env:
        - name: DB
          value: db
        readinessProbe:
          httpGet:
            path: /demo/hello
            port: 8080
          periodSeconds: 1
        livenessProbe:
          httpGet:
            path: /demo/hello
            port: 8080
        resources:
          limits:
            memory: "10Mi"
            cpu: 0.1
          requests:
            memory: "5Mi"
            cpu: 0.01

---

apiVersion: v1
kind: Service
metadata:
  name: api
  namespace: go-demo-3
spec:
  ports:
  - port: 8080
  selector:
    app: api
```

```bash
kubectl apply \
    -f sa/go-demo-3.yml \
    --record
```

```
namespace "go-demo-3" created
ingress "api" created
serviceaccount "db" created
role "db" created
rolebinding "db" created
statefulset "db" created
service "db" created
deployment "api" created
service "api" created
```

```bash
kubectl -n go-demo-3 \
    get pods
```

```
NAME    READY STATUS  RESTARTS AGE
api-... 1/1   Running 1        1m
api-... 1/1   Running 1        1m
api-... 1/1   Running 1        1m
db-0    2/2   Running 0        1m
db-1    2/2   Running 0        1m
db-2    2/2   Running 0        54s
```

```bash
kubectl -n go-demo-3 \
    logs db-0 -c db-sidecar
```

```json
...
     { _id: 1,
       host: 'db-1.db.go-demo-3.svc.cluster.local:27017',
       arbiterOnly: false,
       buildIndexes: true,
       hidden: false,
       priority: 1,
       tags: {},
       slaveDelay: 0,
       votes: 1 },
     { _id: 2, host: 'db-2.db.go-demo-3.svc.cluster.local:27017' } ],
  settings:
   { chainingAllowed: true,
     heartbeatIntervalMillis: 2000,
     heartbeatTimeoutSecs: 10,
     electionTimeoutMillis: 10000,
     catchUpTimeoutMillis: 2000,
     getLastErrorModes: {},
     getLastErrorDefaults: { w: 1, wtimeout: 0 },
     replicaSetId: 5aef9e4c52b968b72a16ea5b } }
```

```bash
kubectl delete ns go-demo-3
```

## What Now?

* [ServiceAccount v1 core](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#serviceaccount-v1-core)]
* [Role v1 rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#role-v1-rbac)
* [ClusterRole v1 rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrole-v1-rbac)
* [RoleBinding v1 rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#rolebinding-v1-rbac)
* [ClusterRoleBinding v1 rbac](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#clusterrolebinding-v1-rbac)